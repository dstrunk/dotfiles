#+TITLE: Emacs configuration

* Use sensible-defaults.el

Use [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] for basic settings.

#+BEGIN_SRC emacs-lisp
  (load-file "~/.emacs.d/sensible-defaults.el/sensible-defaults.el")
  (sensible-defaults/use-all-settings)
  (sensible-defaults/use-all-keybindings)
#+END_SRC

* Package management

Use =cask= and =pallet= for managing packages.

#+BEGIN_SRC emacs-lisp
  (require 'cask "~/.cask/cask.el")
  (cask-initialize)
  (require 'pallet)
#+END_SRC

* =evil-mode=

Use =evil=, because I'm a Vim convert sinner.

#+BEGIN_SRC emacs-lisp
  (evil-mode 1)
#+END_SRC

Enable =surround= everywhere.

#+BEGIN_SRC emacs-lisp
  (global-evil-surround-mode 1)
#+END_SRC

Enable =commentary=.

#+BEGIN_SRC emacs-lisp
  (evil-commentary-mode)
#+END_SRC

Bind =C-p= to fuzzy-finding files in the current project.

#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
#+END_SRC

Easily move between splits when in normal state.

#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
  (define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
  (define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
  (define-key evil-normal-state-map (kbd "C-l") 'evil-window-right)
#+END_SRC

Resize windows easier

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-C-h") 'enlarge-window-horizontally)
  (global-set-key (kbd "M-C-j") 'enlarge-window)
  (global-set-key (kbd "M-C-k") 'shrink-window)
  (global-set-key (kbd "M-C-l") 'shrink-window-horizontally)
#+END_SRC

* Better terminal workflow

#+BEGIN_SRC emacs-lisp
	(defun emacsredux/visit-term-buffer ()
  "Create or visit a terminal buffer."
  (interactive)
  (if (not (get-buffer "*ansi-term*"))
      (progn
        (split-window-sensibly (selected-window))
        (other-window 1)
        (ansi-term (getenv "SHELL")))
    (switch-to-buffer-other-window "*ansi-term*")))

	(global-set-key (kbd "C-c t") 'emacsredux/visit-term-buffer)
#+END_SRC

* Add line numbers

#+BEGIN_SRC emacs-lisp
	(global-linum-mode 1)
#+END_SRC

* Utility functions

A big ol' bunch of utility functions, setup by our good friend Harry.

#+BEGIN_SRC emacs-lisp
  (defun hrs/view-buffer-name ()
    "Display the filename of the current buffer."
    (interactive)
    (message (buffer-file-name)))

  (defun hrs/generate-scratch-buffer ()
    "Create and switch to a temporary scratch buffer with a random
       name."
    (interactive)
    (switch-to-buffer (make-temp-name "scratch-")))

  (defun hrs/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (other-window 1))

  (defun hrs/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (other-window 1))

  (defun hrs/de-unicode ()
    "Tidy up a buffer by replacing all special Unicode characters
       (smart quotes, etc.) with their more sane cousins"
    (interactive)
    (let ((unicode-map '(("[\u2018\|\u2019\|\u201A\|\uFFFD]" . "'")
                         ("[\u201c\|\u201d\|\u201e]" . "\"")
                         ("\u2013" . "--")
                         ("\u2014" . "---")
                         ("\u2026" . "...")
                         ("\u00A9" . "(c)")
                         ("\u00AE" . "(r)")
                         ("\u2122" . "TM")
                         ("[\u02DC\|\u00A0]" . " "))))
      (save-excursion
        (loop for (key . value) in unicode-map
              do
              (goto-char (point-min))
              (replace-regexp key value)))))

  (defun hrs/beautify-json ()
    "Pretty-print the JSON in the marked region. Currently shells
       out to `jsonpp'--be sure that's installed!"
    (interactive)
    (save-excursion
      (shell-command-on-region (mark) (point) "jsonpp" (buffer-name) t)))

  (defun hrs/comment-or-uncomment-region-or-line ()
    "Comments or uncomments the region or the current line if there's no active region."
    (interactive)
    (let (beg end)
      (if (region-active-p)
          (setq beg (region-beginning) end (region-end))
        (setq beg (line-beginning-position) end (line-end-position)))
      (comment-or-uncomment-region beg end)))

  (defun hrs/unfill-paragraph ()
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive)
    (let ((fill-column (point-max)))
      (fill-paragraph nil)))

  (defun hrs/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (defun hrs/visit-last-dired-file ()
    "Open the last file in an open dired buffer."
    (end-of-buffer)
    (previous-line)
    (dired-find-file))

  (defun hrs/visit-last-migration ()
    "Open the last file in 'db/migrate/'. Relies on projectile. Pretty sloppy."
    (interactive)
    (dired (expand-file-name "db/migrate" (projectile-project-root)))
    (hrs/visit-last-dired-file)
    (kill-buffer "migrate"))

  (defun hrs/mac? ()
    "Returns `t' if this is an Apple machine, nil otherwise."
    (eq system-type 'darwin))

  (defun hrs/add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))

  (defun hrs/find-file-as-sudo ()
    (interactive)
    (let ((file-name (buffer-file-name)))
      (when file-name
        (find-alternate-file (concat "/sudo::" file-name)))))

  (defun hrs/insert-random-string (len)
    "Insert a random alphanumeric string of length len."
    (interactive)
    (let ((mycharset "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstyvwxyz"))
      (dotimes (i len)
        (insert (elt mycharset (random (length mycharset)))))))

  (defun hrs/generate-password ()
    "Insert a good alphanumeric password of length 30."
    (interactive)
    (hrs/insert-random-string 30))
#+END_SRC

* UI Preferences
** Disable window chrome

Get that crap outta here...

#+BEGIN_SRC emacs-lisp
	(tool-bar-mode 0)
	(menu-bar-mode 0)
	(when window-system
		(scroll-bar-mode -1))
#+END_SRC

** Theme

#+BEGIN_SRC emacs-lisp
  (when window-system
    (load-theme 'spacemacs-dark t))
#+END_SRC

Add Spacemacs's mode-line

#+BEGIN_SRC emacs-lisp
  (require 'spaceline-config)
  (spaceline-spacemacs-theme)
  (setq ns-use-srgb-colorspace nil)
#+END_SRC

** Diminished mode

#+BEGIN_SRC emacs-lisp
(defmacro diminish-minor-mode (filename mode &optional abbrev)
  `(eval-after-load (symbol-name ,filename)
     '(diminish ,mode ,abbrev)))

(defmacro diminish-major-mode (mode-hook abbrev)
  `(add-hook ,mode-hook
             (lambda () (setq mode-name ,abbrev))))

(diminish-minor-mode 'abbrev 'abbrev-mode)
(diminish-minor-mode 'company 'company-mode)
(diminish-minor-mode 'eldoc 'eldoc-mode)
(diminish-minor-mode 'flycheck 'flycheck-mode)
(diminish-minor-mode 'flyspell 'flyspell-mode)
(diminish-minor-mode 'global-whitespace 'global-whitespace-mode)
(diminish-minor-mode 'projectile 'projectile-mode)
(diminish-minor-mode 'ruby-end 'ruby-end-mode)
(diminish-minor-mode 'subword 'subword-mode)
(diminish-minor-mode 'undo-tree 'undo-tree-mode)
(diminish-minor-mode 'yard-mode 'yard-mode)
(diminish-minor-mode 'yasnippet 'yas-minor-mode)
(diminish-minor-mode 'wrap-region 'wrap-region-mode)

(diminish-minor-mode 'paredit 'paredit-mode " π")

(diminish-major-mode 'emacs-lisp-mode-hook "el")
(diminish-major-mode 'haskell-mode-hook "λ=")
(diminish-major-mode 'lisp-interaction-mode-hook "λ")
(diminish-major-mode 'python-mode-hook "Py")
#+END_SRC

** Highlight the current line

=global-hl-line-mode= to softly highlight the background color of the line containing point.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (global-hl-line-mode)
    (set-face-background hl-line-face "gray13"))
#+END_SRC

** Highlight uncommitted changes

Use the =diff-hl= package to highlight changed and uncommitted lines when programming.

#+BEGIN_SRC emacs-lisp
  (require 'diff-hl)

  (global-diff-hl-mode)
  (diff-hl-flydiff-mode)
#+END_SRC

* Programming customizations

** General

Ensure proper PATH if not started from a shell.

#+BEGIN_SRC emacs-lisp
(defadvice rspec-compile (around rspec-compile-around)
  "Use BASH shell for running the specs because of ZSH issues."
  (let ((shell-file-name "/bin/bash"))
    ad-do-it))

(ad-activate 'rspec-compile)
#+END_SRC

Enable =smartparens=.

#+BEGIN_SRC emacs-lisp
  (smartparens-global-mode t)
  (require 'smartparens-config)
#+END_SRC

When using =smartparens=, if I hit enter I expect to be indented on a new line with the closing paren below my cursor. The below function is to be used in various modes to make life easier. This is detailed here: https://github.com/Fuco1/smartparens/issues/80

```lisp
	(sp-local-pair 'c++-mode "{" nil :post-handlers '((dstrunk/create-newline-and-enter-sexp "RET")))
```

#+BEGIN_SRC emacs-lisp
  (defun dstrunk/create-newline-and-enter-sexp (&rest _ignored)
		"Open a new brace or bracket expression, with relevant newlines and indent. "
 		(newline)
 		(indent-according-to-mode)
 		(forward-line -1)
 		(indent-according-to-mode))
#+END_SRC

** CSS and Sass

Indent 2 spaces and put my pointer in the right place.

#+BEGIN_SRC emacs-lisp
  (add-hook 'css-mode-hook
            (lambda()
              (setq css-indent-offset 2)))

	(sp-local-pair 'css-mode "{" nil :post-handlers '((dstrunk/create-newline-and-enter-sexp "RET")))
#+END_SRC

Don't compile the current file on every save.

#+BEGIN_SRC emacs-lisp
  (setq scss-compile-at-save nil)
#+END_SRC

** JavaScript, Coffeescript, TypeScript and Elm

Indent 2 spaces.

#+BEGIN_SRC emacs-lisp
  (setq js-indent-level 2)

  (add-hook 'coffee-mode-hook
            (lambda()
              (yas-minor-mode 1)
              (setq coffee-tab-width 2)))

        (sp-local-pair 'coffee-mode "{" nil :post-handlers '((dstrunk/create-newline-and-enter-sexp "RET")))
        (sp-local-pair 'coffee-mode "[" nil :post-handlers '((dstrunk/create-newline-and-enter-sexp "RET")))
        (sp-local-pair 'js-mode "{" nil :post-handlers '((dstrunk/create-newline-and-enter-sexp "RET")))
        (sp-local-pair 'js-mode "[" nil :post-handlers '((dstrunk/create-newline-and-enter-sexp "RET")))
#+END_SRC

*** Setup TypeScript

All setup via https://github.com/ananthakumaran/tide

#+BEGIN_SRC emacs-lisp
  (defun setup-tide-mode ()
    (interactive)
    (tide-setup)
    (flycheck-mode +1)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (eldoc-mode +1)
    ;; company is an optional dependency. You have to
    ;; install it separately via package-install
    (company-mode +1))

  ;; aligns annotation to the right hand side
  (setq company-tooltip-align-annotations t)

  ;; formats the buffer before saving
  (add-hook 'before-save-hook 'tide-format-before-save)

  ;; format options
  (setq tide-format-options '(:insertSpaceAfterFunctionKeywordForAnonymousFunctions t :placeOpenBraceOnNewLineForFunctions nil))
  ;; see https://github.com/Microsoft/TypeScript/blob/cc58e2d7eb144f0b2ff89e6a6685fb4deaa24fde/src/server/protocol.d.ts#L421-473 for the full list available options

  (add-hook 'typescript-mode-hook #'setup-tide-mode)
#+END_SRC

Use =smartparens= to autocomplete blocks and ensure my pointer is correctly positioned.

#+BEGIN_SRC emacs-lisp
  (sp-local-pair 'typescript-mode "{" nil :post-handlers '((dstrunk/create-newline-and-enter-sexp "RET")))
  (sp-local-pair 'typescript-mode "[" nil :post-handlers '((dstrunk/create-newline-and-enter-sexp "RET")))
  (sp-local-pair 'jsx-mode "{" nil :post-handlers '((dstrunk/create-newline-and-enter-sexp "RET")))
  (sp-local-pair 'jsx-mode "[" nil :post-handlers '((dstrunk/create-newline-and-enter-sexp "RET")))
#+END_SRC

**** TSX

#+BEGIN_SRC emacs-lisp
  (require 'web-mode)
  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . web-mode))
  (add-hook 'web-mode-hook
            (lambda ()
              (when (string-equal "tsx" (file-name-extension buffer-file-name))
                (setup-tide-mode))))
#+END_SRC emacs-lisp

**** JavaScript

#+BEGIN_SRC emacs-lisp
  (add-hook 'js2-mode-hook #'setup-tide-mode)
#+END_SRC

**** JSX

#+BEGIN_SRC emacs-lisp
  (require 'web-mode)
  (add-to-list 'auto-mode-alist '("\\.jsx\\'" . web-mode))
  (add-hook 'web-mode-hook
            (lambda ()
              (when (string-equal "jsx" (file-name-extension buffer-file-name))
                (setup-tide-mode))))
#+END_SRC

**** Elm

To get full autocompletion for Elm, you'll also need to install =elm-oracle= via npm:

#+BEGIN_SRC bash
npm install -g elm-oracle
#+END_SRC

#+BEGIN_SRC emacs-lisp
	(require 'elm-mode)
	(add-hook 'elm-mode-hook #'elm-oracle-setup-completion)
	(add-hook 'elm-mode-hook
						(lambda()
							(setq company-backends '(company-elm))))
#+END_SRC

** Lisps

I don't write in many lisps, but dabbling in Clojure and working in elisp is enough to warrant these. Use =paredit-mode= to balance parentheses, and =rainbow-delimiters= to color match parentheses.

#+BEGIN_SRC emacs-lisp
  (setq lispy-mode-hooks
        '(clojure-mode-hook
          emacs-lisp-mode-hook
          lisp-mode-hook
          scheme-mode-hook))

  (dolist (hook lispy-mode-hooks)
    (add-hook hook (lambda()
                    (setq show-paren-style 'expression)
                    (paredit-mode)
                    (rainbow-delimiters-mode))))
#+END_SRC

If writing Emacs lisp, use =eldoc-mode= to display documentation.

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

** Elixir

- Require =elixir-mode=.
- Require =alchemist=.

#+BEGIN_SRC emacs-lisp
  (require 'elixir-mode)
  (require 'alchemist)
#+END_SRC

Use =smartparens= to autocomplete blocks and ensure my pointer is correctly positioned.

#+BEGIN_SRC emacs-lisp
  (defun dstrunk/elixir-do-end-action (id action context)
    (when (eq action 'insert)
      (newline-and-indent)
      (previous-line)
      (indent-according-to-mode)))

  (sp-with-modes '(elixir-mode)
  (sp-local-pair "do" "end"
         :when '(("SPC" "RET"))
         :post-handlers '(:add dstrunk/elixir-do-end-action)
         :actions '(insert navigate)))

  (sp-local-pair 'elixir-mode "{" nil :post-handlers '((dstrunk/create-newline-and-enter-sexp "RET")))
  (sp-local-pair 'elixir-mode "[" nil :post-handlers '((dstrunk/create-newline-and-enter-sexp "RET")))
#+END_SRC

** Ruby and Rails
Set a default ruby version for things like =rspec=.

#+BEGIN_SRC emacs-lisp
(global-rbenv-mode)
(or (rbenv-use-corresponding) (rbenv-use-global))
#+END_SRC

Some defaults for Ruby:

- Don't insert an encoding comment
- enable =yas=, =rspec=, =yard=, =flycheck=, and =projectile-rails=
- RSpec tests run in a random order with colored output

#+BEGIN_SRC emacs-lisp
(setq rspec-use-bundler-when-possible nil)

(add-hook 'ruby-mode-hook
          (lambda ()
            (setq ruby-insert-encoding-magic-comment nil)
            (yas-minor-mode)
            (rspec-mode)
            (yard-mode)
            (flycheck-mode)
            (local-set-key "\r" 'newline-and-indent)
            (setq rspec-command-options "--color --order random")
            (projectile-rails-mode)))
#+END_SRC

Associate =ruby-mode= with the usual suspects: Gemfiles, gemspecs, Rakefiles, and Vagrantfiles.

#+BEGIN_SRC emacs-lisp
(hrs/add-auto-mode
  'ruby-mode
  "\\Gemfile$"
  "\\.rake$"
  "\\.gemspec$"
  "\\Guardfile$"
  "\\Rakefile$"
  "\\Vagrantfile$"
  "\\Vagrantfile.local$")
#+END_SRC

When running RSpec tests, scroll to the first error.

#+BEGIN_SRC emacs-lisp
(add-hook 'rspec-compilation-mode-hook
          (lambda ()
            (make-local-variable 'compilation-scroll-output)
            (setq compilation-scroll-output 'first-error)))
#+END_SRC
** PHP

Enable =php-mode= whenever opening a php file.

#+BEGIN_SRC emacs-lisp
	(require 'php-mode)
#+END_SRC

Auto-indent and newline brackets

#+BEGIN_SRC emacs-lisp
	(sp-local-pair 'php-mode "{" nil :post-handlers '((dstrunk/create-newline-and-enter-sexp "RET")))
#+END_SRC

** =web-mode=

Indent everything with 2 spaces.

#+BEGIN_SRC emacs-lisp
  (add-hook 'web-mode-hook
            (lambda ()
              (setq web-mode-markup-indent-offset 2)))
#+END_SRC

Use =web-mode= with embedded Ruby files, regular HTML, Elixir and Magento template files.

#+BEGIN_SRC emacs-lisp
  (hrs/add-auto-mode
    'web-mode
    "\\.erb$"
    "\\.html$"
    "\\.rhtml$"
    "\\.phtml$"
    "\\.eex$")
#+END_SRC

Use =emmet-mode= for markup modes. Also setup some defaults:

- position cursor between first empty quotes after expanding.
- use emmet with react-js's JSX

#+BEGIN_SRC emacs-lisp
  (add-hook 'sgml-mode-hook 'emmet-mode)
  (add-hook 'css-mode-hook 'emmet-mode)
  (setq emmet-move-cursor-between-quotes t)
  (setq emmet-expand-jsx-className? t)
#+END_SRC

** =magit=

Use =magit= for git things

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)

  (setq git-commit-fill-column 80)
#+END_SRC

** Bash

Ensure my Emacs PATH looks like my terminal (OS X only)

#+BEGIN_SRC emacs-lisp
  (when (memq window-system '(mac ns))
    (exec-path-from-shell-initialize))
#+END_SRC

* Publishing and task management with Org-mode

** Display preferences

Use syntax highlighting in source blocks while editing.

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

Make TAB act as if it were issued in a buffer of the language's major mode.

#+BEGIN_SRC emacs-lisp
  (setq org-src-tab-acts-natively t)
#+END_SRC

** Task management

This is a hell of a good =org-mode= config: https://github.com/howardabrams/dot-files/blob/master/emacs-org.org. I will probably borrow more tricks from this configuration later, but for now am only adding the things that I understand / will need.

Store org files in =~/Dropbox/org=, maintain an inbox in Dropbox, define the location of an index file (main todo list), and archive finished tasks in =~/Dropbox/org/archive.org=. For help on everything to do with =org-mode=, check out http://orgmode.org/.

#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/Dropbox/org/")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (setq org-inbox-file (org-file-path "inbox.org"))
  (setq org-todo-file (org-file-path "todo.org"))
  (setq org-journal-dir (org-file-path "journal/"))
  (setq org-archive-location
        (concat (org-file-path "archive.org") "::* From %s"))
#+END_SRC

All todos are stored in =~/Dropbox/org/todo.org=, so agenda should be derived from here.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list "~/Dropbox/org"
                                "~/Dropbox/org/journal"))
#+END_SRC

Hitting =C-c C-x C-s= will mark a todo as done and move it to the appropriate place in the archive.

#+BEGIN_SRC emacs-lisp
  (defun mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key global-map "\C-c\C-x\C-s" 'mark-done-and-archive)
#+END_SRC

Record the time a todo was archived.

#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

Set a default target for notes, and define a global key for capturing new material.

#+BEGIN_SRC emacs-lisp
  (setq org-default-notes-file (concat org-directory "/notes.org"))
  (define-key global-map "\C-cc" 'org-capture)
	(define-key global-map "\C-ca" 'org-agenda)
#+END_SRC

Capture templates for various things:

- Todos
- Journal entries

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
    '(("t" "Todo" entry (file+headline org-todo-file "Tasks")
          "* TODO %?\n %i\n  %a")))
#+END_SRC

Add default TODO keywords, and make their fonts pretty

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords '((sequence "TODO(t!)" "DOING(g!)" "|" "DONE(d@/!)")
										      (sequence "|" "CANCELLED(c@/!)")))

(font-lock-add-keywords              ; A bit silly but my headers are now
   'org-mode `(("^\\*+ \\(TODO\\) "  ; shorter, and that is nice cancelled
                (1 (progn (compose-region (match-beginning 1) (match-end 1) "⚑")
                          nil)))
               ("^\\*+ \\(DOING\\) "
                (1 (progn (compose-region (match-beginning 1) (match-end 1) "⚐")
                          nil)))
               ("^\\*+ \\(CANCELLED\\) "
                (1 (progn (compose-region (match-beginning 1) (match-end 1) "✘")
                          nil)))
               ("^\\*+ \\(DONE\\) "
                (1 (progn (compose-region (match-beginning 1) (match-end 1) "✔")
                          nil)))))

#+END_SRC

** Journaling

For journal entries, I'd like to use =olivetti=.

#+BEGIN_SRC emacs-lisp
(dir-locals-set-class-variables 'org-journal-settings
  '((nil . ((org-mode . t)
            (linum-mode . -1)
            (olivetti-mode . t)
            (flyspell-mode . 1)))))

(dir-locals-set-directory-class org-journal-dir 'org-journal-settings)
#+END_SRC

* =dired=

Load up the required =dired= extensions.

#+BEGIN_SRC emacs-lisp
  (require 'dired-x)
  (require 'dired+)
  (require 'dired-open)
#+END_SRC

Open media with the appropriate programs.

#+BEGIN_SRC emacs-lisp
  (setq dired-open-extensions
        '(("pdf" . "evince")
          ("mkv" . "vlc")
          ("mp4" . "vlc")
          ("avi" . "vlc")))
#+END_SRC

Pass some switches to =ls= when =dired= gets a list of files:

- =l=: use the long listing format.
- =h=: use human-readable sizes.
- =v=: sort numbers naturally.
- =A=: almost all. Doesn't include "=.=" or "=..=".

#+BEGIN_SRC emacs-lisp
  (setq-default dired-listing-switches "-lhvA")
#+END_SRC

Use "j" and "k" to move around in =dired=.

#+BEGIN_SRC emacs-lisp
  (evil-define-key 'normal dired-mode-map (kbd "j") 'dired-next-line)
  (evil-define-key 'normal dired-mode-map (kbd "k") 'dired-previous-line)
#+END_SRC

Kill buffers of files/directories deleted in =dired=.

#+BEGIN_SRC emacs-lisp
  (setq dired-clean-up-buffers-too t)
#+END_SRC

Always copy directories recursively instead of asking everytime.

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-copies 'always)
#+END_SRC

Ask before recursively /deleting/ a directory, though.

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-deletes 'top)
#+END_SRC

* Editing settings

** Always kill current buffer

Assume I want to kill the current buffer when hitting =C-x k=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x k") 'hrs/kill-current-buffer)
#+END_SRC

** Look for executables in =~/.bin=.

#+BEGIN_SRC emacs-lisp
  (setq exec-path (append exec-path '("$HOME/.bin")))
#+END_SRC

** Use =company-mode= everywhere.

Company mode is a text completion mode ("company" stands for "complete anything").

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

** Always indent with spaces

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Configure =yasnippet=

Keep snippets in =~/.emacs.d/snippets/text-mode=, and always keep enabled.

#+BEGIN_SRC emacs-lisp
  (setq yas-snippet-dirs '("~/.emacs.d/snippets/text-mode"))
  (yas-global-mode 1)
#+END_SRC

Don't automatically indent snippets inserted.

#+BEGIN_SRC emacs-lisp
  (setq yas/indent-line nil)
#+END_SRC

** Configure =ido=

#+BEGIN_SRC emacs-lisp
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (ido-mode 1)
  (ido-ubiquitous)
  (flx-ido-mode 1) ; faster matching
  (setq ido-create-new-buffer 'always)
  (ido-vertical-mode 1)
  (setq ido-vertical-define-keys 'C-n-and-C-p-only)
#+END_SRC

** Use =smex= to handle =M-x= with =ido=

#+BEGIN_SRC emacs-lisp
  (smex-initialize)

  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)
#+END_SRC

** Editing with markdown

Run spellcheck when editing markdown, and use =olivetti= for a nicer editing experience.

#+BEGIN_SRC emacs-lisp
	(add-hook 'markdown-mode-hook
						'(lambda()
						   (linum-mode -1)
						   (olivetti-mode)
							 (flyspell-mode 1)))
#+END_SRC

Associate =.md= files with markdown.

#+BEGIN_SRC emacs-lisp
  (hrs/add-auto-mode 'markdown-mode "\\.md$")
#+END_SRC

** Use =projectile= everywhere

#+BEGIN_SRC emacs-lisp
  (projectile-global-mode)
#+END_SRC
